<!DOCTYPE html>
<html>
    <head>    
        <title id="ref-title">{{ ref }}</title>
        <script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script>
        <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin></script>
        <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin></script>
        <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
        {% load static %}
        <link rel="stylesheet" type="text/css" href="{% static 'mem_app/styles.css' %}">
        <link href="https://fonts.googleapis.com/css?family=Cousine|Lato|Montserrat&display=swap" rel="stylesheet"> 
    </head>
    <body>
        <div id="app"></div>
        <script type="text/babel">
            "use strict"
            class Verse extends React.Component {
                render() {
                    return(
                        <div>
                            <h3>Current Score: {this.props.score}%</h3>
                            <div className="verse-to-mem">
                                <span id="spanRef">{this.props.reference}</span><br/>
                                <span id="spanText">{this.props.text}</span>
                            </div>
                            <div className="divVerseControls">
                                <br/>
                                <button onClick={this.props.restoreWords} className="btnVerseControls" id="btnRestoreWords">Restore Words</button>
                                <button onClick={this.props.removeWords} className="btnVerseControls" id="btnRemoveWords">Remove Words</button><br/>
                                <button onClick={this.instructions} id="btn-instructions">Instructions</button>
                                <button onClick={this.props.changeMode} id="btn-grade-mode">Attempt</button>
                                <div id="modal-instructions" className="modal">
                                    <div className="modal-content">
                                        <span id="close">&times;</span>
                                        <p>
                                         Say the verse outloud, or write it down. Then click the <span className="txt-emphasis-blue">Remove Words</span> Button to remove
                                         a random number of words. If you need to go back, click the <span className="txt-emphasis-green">Restore Words</span> button.
                                         Repeat the process until you can say or write the entire verse with no words showing.
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )
                }

                instructions = () => {
                    // get modal and close button
                    const modal = document.querySelector("#modal-instructions");
                    const btnClose = document.querySelector("#close");

                    // display modal
                    modal.style.display = "block";

                    // close modal
                    btnClose.onclick = () => {
                        modal.style.display = "none";
                    }
                    window.onclick = (event) => {
                        if (event.target == modal){
                            modal.style.display = "none";
                        }
                    };
                }
            }

            class Grade extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = {
                        grade: 0,
                        feedback: "",
                    }
                }

                render() {
                    return(
                        <div className="div-main">
                            <h3>Verse Grading</h3>
                            <textarea id="textarea-verse" rows="8" cols="90" autoFocus placeholder="Verse Reference&#13;&#10;Verse Body..."></textarea><br/>
                            <button onClick={this.gradeVerse} className="btnVerseControls">Submit</button><br/>
                            <button onClick={this.props.changeMode} id="btn-study-mode">Study Verse</button>
                            <div id="modal-feedback" className="modal">
                                <div className="modal-content">
                                    <span id="close-feedback">&times;</span>
                                    <h3 id="percent">Your Score: {this.state.grade}</h3>
                                    <p id="feedback">{this.state.feedback}</p>
                                </div>
                            </div>
                        </div>
                    );
                }

                gradeVerse = () => {
                    const regex = /[^A-za-z0-9 \t]/gi;
                    const regex2 = /[\r\n]/gi;

                    // remove non-alphabetic characters, convert verse to list of words
                    const verseText = this.props.text.replace(regex, "").split(" ");

                    //add reference to begining of verseText array
                    const ref = this.props.reference.replace(regex, "").split(" ");
                    verseText.unshift(ref[0], ref[1]);

                    //convert user's attempt to list of words
                    const rawText = document.getElementById("textarea-verse").value.replace(regex2, " ");
                    const verseAttempt = rawText.replace(regex, "").split(" ");
                    const verseRaw = verseAttempt.slice(0);
                    
                    // prepare error and score storage
                    let score = 0;
                    const errorsIndex = [];

                    // compare verses
                    for (let i = 0; i < verseAttempt.length; i++) {
                        // bool dictates if an extra word should be added back in to the array
                        // when displaying the graded verse to the user
                        let bool = false;

                        // increase score if words match
                        if (verseAttempt[i] === verseText[i]) {
                            score += 1;
                        }

                        // decrease score, store error info there are
                        // extra words at the end of user's input
                        else if(verseText[i] === undefined){
                            score -= 1;
                            errorsIndex.push([i, bool]);
                        }

                        else {
                            // prepare error text
                            let errorText = verseAttempt[i];

                            // decrease score if words do not match
                            score -= 1;

                            // if error seems like an extra word
                            if (verseAttempt[i + 1] === verseText[i]) {
                                bool = true;
                                errorText = verseAttempt[i];
                                verseAttempt.splice(i, 1);
                            }
                            // if error seems like a missing word
                            else if (verseAttempt[i] === verseText[i + 1]) {
                                verseAttempt.splice(i, 0, "____");
                            }
                            else{}
                            // record error
                            errorsIndex.push([i, bool, errorText]);
                        }
                    }
                    // sort errors, smaller index's first
                    errorsIndex.sort((a, b) => a[0] - b[0]);
                    let percent = Math.round(score / verseText.length * 100);
                    
                    let index = 0;
                    for (let j = 0; j < verseAttempt.length; j++) {
                        console.log(index);
                        if (errorsIndex[index] === undefined){
                            break;
                        }
                        if (j === errorsIndex[index][0]) {
                            // insert previously removed words back into users's attempt (for feedback)
                            if (errorsIndex[index][1]) {
                                verseAttempt.splice(j, 0, errorsIndex[index][2]);
                            }
                            verseAttempt[j] = "<span class='text-error'>" + verseAttempt[j] + "</span>";
                            index++;
                        }
                    }

                    // update feedback modal
                    if (percent < 0){
                        percent = 0;
                    }
                    this.setState({
                        grade: percent.toString() + "%",
                    });
                    document.querySelector("#feedback").innerHTML = verseAttempt.join(" ");

                    // update App state
                    this.props.handleState(percent);

                    //send info to server
                    const url = "http://127.0.0.1:8000/update-score";
                    const data = {
                        score: percent,
                        reference: this.props.reference,
                    }

                    fetch(url,{
                        method: "POST",
                        credentials: "include",
                        headers: {
                            "X-CSRFToken": Cookies.get("csrftoken"),
                            "Content-type": "application/json",
                            "X-Requested-With": "XMLHttpRequest"
                        },
                        body: JSON.stringify(data)
                    }).then(res => res.json())
                    .then(response => {
                        if (response.status !== "success"){
                            alert("Your verse's score was not saved");
                        }
                    })
                    .catch(error => {
                        console.error("Error:", error);
                    });

                    // get modal and close button
                    const modal = document.querySelector("#modal-feedback");
                    const btnClose = document.querySelector("#close-feedback");

                    // display modal
                    modal.style.display = "block";

                    // close modal
                    btnClose.onclick = () => {
                        modal.style.display = "none";
                    }
                    window.onclick = (event) => {
                        if (event.target == modal){
                            modal.style.display = "none";
                        }
                    };
                }
            }

            class App extends React.Component {
                constructor(props) {
                    super(props);
                    this.state = {
                        ref: document.querySelector("#ref-title").innerHTML,
                        text: "",
                        cachedText: [],
                        cacheIndex: 0,
                        gradeMode: false,
                        score: ""
                    }
                }

                componentDidMount() {
                    const url = `http://127.0.0.1:8000/verse/${this.state.ref}`;

                    fetch(url)
                        .then(res => res.json())
                        .then(response => {
                            // check if server could not find user's verse
                            if (response.text === null) {
                                this.setState(state => ({
                                    text: "No such verse associated with your Account.",
                                    cachedText: [...state.cachedText, "No such verse associated with your account."]
                                }));
                                document.querySelector("#btnRemoveWords").disabled = true;
                            }
                            // update state to match user's verse
                            else {
                                this.setState(state => ({
                                    text: response.text,
                                    cachedText: [...state.cachedText, response.text],
                                    score: response.score
                                }));
                            }
                        })
                        .catch(error => {
                            // update state to display error
                            this.setState(state => ({
                                ref: "Sorry:",
                                text: "An Error Occured",
                                cachedText: [...state.cachedText, "An Error Occured."]
                            }));
                            document.querySelector("#btnRemoveWords").disabled = true;
                            console.error("Error:", error);
                        });
                    
                    // disable restore button since no has been removed yet
                    if (this.state.cacheIndex === 0){
                        document.querySelector("#btnRestoreWords").disabled = true;
                    }
                }

                randomInt(min, max) {
                    // return and random integer that is equal to min, or just under max
                    // function from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random
                    return Math.floor(Math.random() * (max - min) + min);
                }

                removeWords = () => {
                    // enable restore if necessary
                    if (document.querySelector("#btnRestoreWords").disabled){
                        document.querySelector("#btnRestoreWords").disabled = false;
                    }

                    // blank out reference if all words are already blank, disable button
                    if (this.state.text.search(/[^_ ]/) === -1){
                        document.querySelector("#btnRemoveWords").disabled = true;
                        this.setState({
                            ref: "_____________"
                        });
                        return;
                    }
                    const currText = this.state.text.split(" ");
                    const numOfWords = this.randomInt(1, 5);

                    // remove random number of words (between 1, 5)
                    for(let i = 0; i < numOfWords; i++){
                        const index = this.randomInt(0, currText.length);
                        let blank = "";

                        // build a "blank" string same length as the word
                        for (let j = 0; j < currText[index].length; j++){
                            blank += "_";
                        }

                        // skip iteration if chosen work is already blank
                        if (currText[index].includes("_")) {
                            i--;
                            continue;
                        }

                        // restore word
                        currText[index] = blank;

                        // end loop if all words are blank
                        if(currText.join("").search(/[^_]/) === -1){
                            break;
                        }
                    }
                    // update state
                    this.setState(state => ({
                        text: currText.join(" "),
                        cachedText: [...state.cachedText, currText.join(" ")],
                        cacheIndex: state.cachedText.length
                    }));
                }

                restoreWords = () => {
                    // enable remove if necessary
                    if (document.querySelector("#btnRemoveWords").disabled){
                        document.querySelector("#btnRemoveWords").disabled = false;
                    }   

                    // check if cache is empty
                    if (this.state.cacheIndex === 0){
                        this.setState({
                            ref: document.querySelector("#ref-title").innerHTML,
                        })
                        document.querySelector("#btnRestoreWords").disabled = true;
                        return;
                    }

                    // remove last cached step, update text to previous cached step
                    const cache = this.state.cachedText;
                    cache.pop();
                    this.setState({
                        text: this.state.cachedText[this.state.cacheIndex - 1],
                        cachedText: cache,
                        cacheIndex: this.state.cacheIndex - 1
                    });
                }

                changeMode = () => {
                    this.setState({
                        gradeMode: !this.state.gradeMode
                    });
                }

                handleState = (newScore) => {
                    this.setState({
                        score: newScore
                    });
                }

                render() {
                    if (this.state.gradeMode) {
                        return(
                            <Grade
                                changeMode={this.changeMode}
                                text={this.state.cachedText[0]}
                                reference={this.state.ref}
                                handleState={this.handleState}
                            />
                        )
                    }
                    else {
                        return(
                            <Verse 
                                reference={this.state.ref}
                                text={this.state.text}
                                removeWords={this.removeWords}
                                restoreWords={this.restoreWords}
                                changeMode={this.changeMode}
                                score={this.state.score}
                            />
                        )
                    }
                }
            }

            ReactDOM.render(<App/>, document.querySelector("#app"));
        </script>
    </body><br/><br/><hr/>
    <footer>
        <div>
            <span>
                Unless otherwise indicated, all Scripture quotations are from the ESV® Bible (The Holy Bible, English Standard Version®), copyright © 2001 by Crossway, 
                a publishing ministry of Good News Publishers. Used by permission. All rights reserved. You may not copy or download more than 500 consecutive verses of
                the ESV Bible or more than one half of any book of the ESV Bible.
            </span>
        </div>
    </footer>
</html>